create table public.rehearsals (
  id uuid not null default gen_random_uuid (),
  project_id uuid not null,
  start_datetime timestamp with time zone not null,
  end_datetime timestamp with time zone not null,
  location text null,
  scene_details text null,
  created_by uuid not null,
  status character varying(20) null default 'scheduled'::character varying,
  created_at timestamp with time zone null default now(),
  updated_at timestamp with time zone null default now(),
  deleted_at timestamp with time zone null,
  constraint rehearsals_pkey primary key (id),
  constraint rehearsals_created_by_fkey foreign KEY (created_by) references users (id),
  constraint rehearsals_project_id_fkey foreign KEY (project_id) references projects (id) on delete CASCADE,
  constraint rehearsals_status_check check (
    (
      (status)::text = any (
        (
          array[
            'scheduled'::character varying,
            'updated'::character varying,
            'cancelled'::character varying
          ]
        )::text[]
      )
    )
  ),
  constraint valid_time_range check ((end_datetime > start_datetime))
) TABLESPACE pg_default;

create index IF not exists idx_rehearsals_project on public.rehearsals using btree (project_id) TABLESPACE pg_default;

create index IF not exists idx_rehearsals_start_time on public.rehearsals using btree (start_datetime) TABLESPACE pg_default;

create index IF not exists idx_rehearsals_creator on public.rehearsals using btree (created_by) TABLESPACE pg_default;

create index IF not exists idx_rehearsals_status on public.rehearsals using btree (status) TABLESPACE pg_default;

create index IF not exists idx_rehearsals_active on public.rehearsals using btree (project_id, start_datetime) TABLESPACE pg_default
where
  (deleted_at is null);

create trigger update_rehearsals_updated_at BEFORE
update on rehearsals for EACH row
execute FUNCTION update_updated_at_column ();